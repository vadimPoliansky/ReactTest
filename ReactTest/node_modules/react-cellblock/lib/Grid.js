/*
 * The top level Grid component
 * Only used once per page
 */
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Column = require('./Column');

var _Column2 = _interopRequireDefault(_Column);

var _utilStyle = require('./util/Style');

var _utilStyle2 = _interopRequireDefault(_utilStyle);

var _eventlistener = require('eventlistener');

var _eventlistener2 = _interopRequireDefault(_eventlistener);

var _utilContext = require('./util/context');

var _utilContext2 = _interopRequireDefault(_utilContext);

var _utilGetThreshold = require('./util/getThreshold');

var _utilGetThreshold2 = _interopRequireDefault(_utilGetThreshold);

var _utilValidators = require('./util/validators');

/*
 * A patch:
 * shouldComponentUpdate() can block context updates
 * so we need to add a fallback method for
 * updating interested components.
 * When React offers a better way, this should be removed
 */
// everytime grid changes, increment so we can check for staleness

var _utilHandleStaleContext = require('./util/handleStaleContext');

var breakCount = 0;
var Grid = (function (_Component) {
  _inherits(Grid, _Component);

  _createClass(Grid, null, [{
    key: 'propTypes',
    value: {
      breakpoints: _utilValidators.validBreakpoints,
      children: _react.PropTypes.any,
      className: _react.PropTypes.string,
      columnWidth: _react.PropTypes.number,
      flexible: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.array]),
      gutterWidth: _react.PropTypes.number,
      initialBreakpoint: _utilValidators.validBreakpoint,
      onChange: _react.PropTypes.func
    },
    enumerable: true
  }, {
    key: 'childContextTypes',
    value: _utilContext2['default'],
    enumerable: true
  }, {
    key: 'defaultProps',
    value: {
      onChange: function onChange() {},
      columnWidth: 60,
      gutterWidth: 20,
      breakpoints: [4, 8, 12, 16],
      flexible: [4]
    },
    enumerable: true
  }]);

  function Grid(props) {
    _classCallCheck(this, Grid);

    _Component.call(this, props);
    this.state = {
      breakpoint: this.props.initialBreakpoint
    };
    this.syncGrid = this.syncGrid.bind(this);
    this.updateGrid = this.updateGrid.bind(this);
  }

  Grid.prototype.getChildContext = function getChildContext() {
    var props = this.props;

    var getViewport = (function () {
      return [this.state.breakpoint, this.getMaxBreatPoint(this.state.breakpoint)];
    }).bind(this);

    return {
      cellblockGet: function cellblockGet(key) {
        switch (key) {
          case 'gutterWidth':
            return props.gutterWidth;
          case 'columnWidth':
            return props.columnWidth;
          case 'viewport':
            return getViewport();
        }
      }
    };
  };

  Grid.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props;
    var breakpoints = _props.breakpoints;
    var columnWidth = _props.columnWidth;
    var gutterWidth = _props.gutterWidth;

    var thresholds = breakpoints.map(function (p) {
      return p * columnWidth + p * gutterWidth;
    });
    var breakpoint = this.state.breakpoint || this.props.breakpoints[_utilGetThreshold2['default'](thresholds)];

    this.setState({
      breakpoint: breakpoint,
      thresholds: thresholds,
      breakCount: 0 });
  };

  // for patch

  Grid.prototype.componentDidMount = function componentDidMount() {
    this.syncGrid(true);
    _eventlistener2['default'].add(window, 'resize', this.syncGrid);
  };

  Grid.prototype.componentWillUnmount = function componentWillUnmount() {
    _eventlistener2['default'].remove(window, 'resize', this.syncGrid);
  };

  Grid.prototype.getMaxBreatPoint = function getMaxBreatPoint(minBreakpoint) {
    var _props2 = this.props;
    var breakpoints = _props2.breakpoints;
    var flexible = _props2.flexible;

    if (!flexible || Array.isArray(flexible) && flexible.indexOf(minBreakpoint) === -1) {
      return minBreakpoint;
    } else {
      var nextPoint = breakpoints[breakpoints.indexOf(minBreakpoint) + 1];
      return nextPoint || breakpoints[breakpoints.length - 1];
    }
  };

  Grid.prototype.syncGrid = function syncGrid(triggerChange) {
    var b = this.props.breakpoints[_utilGetThreshold2['default'](this.state.thresholds)];
    var isChange = b !== this.state.breakpoint;
    if (isChange) this.updateGrid(b);
    if (isChange || triggerChange === true) this.props.onChange(b);
  };

  Grid.prototype.updateGrid = function updateGrid(b) {
    breakCount = breakCount += 1; // This is for the patch

    this.setState({
      breakpoint: b,
      breakCount: breakCount // This is for the patch
    });

    _utilHandleStaleContext.updateObservers(breakCount); // This is for the patch
  };

  Grid.prototype.render = function render() {
    var _state = this.state;
    var breakpoint = _state.breakpoint;
    var breakCount = _state.breakCount;
    var _props3 = this.props;
    var className = _props3.className;
    var gutterWidth = _props3.gutterWidth;
    var children = _props3.children;

    var breakPointRange = [breakpoint, this.getMaxBreatPoint(breakpoint)];
    return _react2['default'].createElement(
      _Column2['default'],
      { isRoot: true, viewport: breakPointRange, breakCount: breakCount, className: className },
      _react2['default'].createElement(_utilStyle2['default'], { gutter: gutterWidth }),
      children
    );
  };

  return Grid;
})(_react.Component);

exports['default'] = Grid;
module.exports = exports['default'];